// This script allows you to correcly input acceleration to an object. 
// Is just an example but should be easy to extrapolate. 
// It needs acc variable as acceleration, brake variable as slowing down value when nothing is pressed
// and ax and ay as instance variables representing the increment of pixels in movement by step, 
// also needs the original position of x and y defined as ox and oy, 
// I don't use startx and starty as this variable could be changed by the origin of ax and ay which could be 0

// An application would be to move an object doing x += ax every step, and to do so we can use the mouse as in this example or we can use something like a keyboard control
// were when pressing "up" for example, would add -1 to a new variable ax1 and change the line var xn = mouse_x by var xn = ax1 and do the same with ay1.
// then the ax would follow ax1 accelerating the object or slowing it down

if mouse_check_button(mb_left) {
	
	var xn = mouse_x // variables del objetivo (se puede sustituir por ax1 o algo por el 
	var yn = mouse_y // estilo que se controle con el teclado)
	
	var dx = xn - ox
	var dy = yn - oy
	var d = sqrt(power(dx, 2) + power(dy, 2))
	
	var ddx = ax - ox
	var ddy = ay - oy
	var dd = sqrt(power(ddx, 2) + power(ddy, 2))
		
	if dd < maxspd or d < dd { // si el objetivo está por debajo del umbral o si ha llegado pero ha vuelto a bajar
		
		var dxn = xn - ax
		var dyn = yn - ay
		var dn = sqrt(power(dxn, 2) + power(dyn, 2))
		
		if dn >= acc { // evita el cimbreo al estar el objetivo y ax/ay muy cerca
		
			if d > dd { // si el objetivo está más lejos del origen que ax/ay
		
				ax += acc * dx / d
				ay += acc * dy / d
		
			} else { // si el objetivo está más cerca del origen que ax/ay
			
				ax += acc * dxn / dn
				ay += acc * dyn / dn
			
			}
		} else {
			
			ax = xn
			ay = yn
						
		}
		
	} else { // si está por encima del umbral
			
		/*ax = maxspd * dx / d + ox
		ay = maxspd * dy / d + oy*/
		
		var zettaAngle = point_direction(ox,oy,xn,yn)
		var alphaAngle = point_direction(ox,oy,ax,ay)
		
		a = zettaAngle
		b = alphaAngle	
		
		var  angleDifference = zettaAngle - alphaAngle
		
		c = angleDifference
		
		if abs(angleDifference) >= acc {
			
			if abs(angleDifference) < 180 {
				ax = maxspd * dcos(alphaAngle + acc * sign(angleDifference)) + ox
				ay = maxspd * -dsin(alphaAngle + acc * sign(angleDifference)) + oy
			} else {
				ax = maxspd * dcos(alphaAngle + acc * -sign(angleDifference)) + ox
				ay = maxspd * -dsin(alphaAngle + acc * -sign(angleDifference)) + oy	
			}
		
		} else {
			
			// pass
			
		}
		
			
	}
		

} else { // si no estoy moviendome ax vuelve a 0 a la velocidad del freno puesto
	
	
	var ddx = ax - ox
	var ddy = ay - oy
	var dd = sqrt(power(ddx, 2) + power(ddy, 2))
	
	if dd >= brake {

		ax -= brake * ddx / dd
		ay -= brake * ddy / dd
	
	} else {
		
		ax = oax
		ay = oay
		
	}
	
}



x = ax
y = ay
